"""
Filename: run_foco.py

Description:
This script simulates both temperature dynamics and solar energy generation for local Fort Collins system.
The simulation accounts for geographic location, system material properties, internal heat generation, fan control, and solar panel performance. 
It can model temperature evolution over time, calculate solar energy production based on panel specifications, 
  and include the effects of shading and internal heat generation. 
Data bounding options using quantiles are also provided for uncertainty analysis.

The simulation results include temperature data, solar energy output, and optional bounded data for uncertainty handling.

Main features:
- Intended for LOCAL validations
- Simulates temperature evolution with convective and radiative heat transfer.
- Models solar energy generation based on panel properties.
- Accounts for internal heat generation and fan cooling effects.
- Optionally bounds data using quantiles for uncertainty analysis.
- Can handle shading effects during specific time ranges.

Author: Kyan Shlipak
Date: 09/28
"""

import numpy as np
import matplotlib.pyplot as plt
from numerical_modelling import *
from datetime import datetime

def run_foco(start_date_time = '2024-06-21 17:00:00', end_date_time = '2024-06-24 09:00:00', internal_rad = True, latitude=40.59,
    longitude=-105.1,
	logging = None,
    T_max=55 + 273.15,
    T_initial=20 + 273.15,
    k=0.162,
    rho=1070,
    Cp=1990,
    emissivity=0.92,
    absorptivity=None,
    battery_mass=1.25,
    battery_Cp=1000,
    battery_emissivity=0.75,
    battery_lengths=[0.151, 0.065, 0.096],
    B_air=0.00367,
    v_air=15.89e-6,
    k_air=0.024,
    alpha_air=22.5e-6,
    h_max=200,
    L=0.2032,
    W=0.152,
    H=0.10922,
    N=6,
    thicknesses=[0.004, 0.004, 0.004, 0.004, 0.004, 0.004],
	fan_flow = 0, #CFM
	heat_generation = 0,
	fan_heat_generation = 0, 
	fan_threshold = 30,
	shading = False,
	shading_ranges = [],
	wind_speed_factor = 1,
	fan_mixing_ratio = 0,
	**kwargs
):
	
	"""
	Simulate temperature predictions and solar energy generation for a system located anywhere on Earth.

	Parameters:
	- latitude (float): Geographic latitude of the location (default: 40.5853, Fort Collins).
	- longitude (float): Geographic longitude of the location (default: -105.0844, Fort Collins).
	- logging (Logger): Logger for tracking the simulation process.
	- T_max (float): Maximum expected temperature for generating stability criterion (K).
	- T_initial (float): Initial temperature of the system (K).
	- k (float): Thermal conductivity of the enclosure material (W/m*K).
	- rho (float): Material density (kg/m³).
	- Cp (float): Specific heat capacity of the enclosure material (J/kg·K).
	- emissivity (float): Emissivity of the material surface.
	- absorptivity (float): Absorptivity of the material surface (usually equal to emissivity).
	- battery_mass (float): Mass of the battery (kg). - currently unused.
	- battery_Cp (float): Specific heat capacity of the battery (J/kg·K). - currently unused.
	- battery_emissivity (float): Emissivity of the battery surface. - currently unused.
	- battery_lengths (list): List of the dimensions of the battery (m). - currently unused.
	- B_air (float): Thermal expansion coefficient of air (1/K).
	- v_air (float): Kinematic viscosity of air (m²/s).
	- k_air (float): Thermal conductivity of air (W/m·K).
	- alpha_air (float): Thermal diffusivity of air (m²/s).
	- h_max (float): Maximum convective heat transfer coefficient (W/m²·K).
	- L (float): Length of the system box (m).
	- W (float): Width of the system box (m).
	- H (float): Height of the system box (m).
	- N (int): Number of discrete points for temperature calculation.
	- thicknesses (list): List of thicknesses of the system plates (m).
	- fan_flow (float): Airflow rate provided by the fan in cfm.
	- heat_generation (float): Internal heat generation within the enclosure (W).
	- fan_heat_generation (float): Heat generated by the fan (W).
	- fan_threshold (float): Temperature threshold to activate the fan (°C).
	- start_date_time (str): Starting date and time of the simulation (format: 'YYYY-MM-DD HH:MM:SS').
	- end_date_time (str): Ending date and time of the simulation (format: 'YYYY-MM-DD HH:MM:SS').
	- solar_panel_area (float): Area of the solar panel (m²).
	- solar_panel_tilt (float): Tilt angle of the solar panel (degrees).
	- solar_panel_azimuth (float): Azimuth angle of the solar panel relative to north (degrees).
	- solar_panel_efficiency (float): Efficiency of the solar panel (%).
	- battery_rated_capacity (float): Rated capacity of the battery (Ah).
	- battery_efficiency (float): Efficiency of the battery (%).
	- dt_solar (int): Time step for solar energy calculations (seconds).
	- power_consumption (float): Constant power consumption of the system (W).
	- bounded (bool): Whether to bound the data using quantiles (default: False).
	- quantiles (list): Quantiles for bounding the data (default: [0.1, 0.9]).
	- stop_event (Event): Event to signal stopping the simulation (default: None).
	- box_shading (bool): Whether to model the system with shading effects (default: False).
	- shading_ranges (list): Time ranges for shading effects, each range defined as a dictionary {t1, t2}.

	Returns:
	- If `bounded` is True:
	- model_df_lower (DataFrame): Lower bound of temperature simulation data.
	- model_df_upper (DataFrame): Upper bound of temperature simulation data.
	- model_df_2023 (DataFrame): Temperature simulation data for the year 2023.
	- solar_df (DataFrame): Solar energy simulation data.
	- If `bounded` is False:
	- model_df (DataFrame): Unbounded temperature simulation data.
	- solar_df (DataFrame): Solar energy simulation data.
	"""

	# Update the local variables using the values in the kwargs dictionary
	locals().update(kwargs)

	# If absorptivity is not provided, set it to the same value as emissivity
	if absorptivity is None:
		absorptivity = emissivity

	# Log the start of the simulation process
	logging.info("*** Modelling Fort Collins ***")

	# Import required library
	import pandas as pd

	# Convert fan flow rate from cfm
	m3_s = fan_flow * 0.0283168 / 60

	# Calculate fan speed based on the average surface area of the enclosure
	fan_speed = m3_s / np.mean([L*W, L*H, W*H])

	# Print fan speed for reference
	print("Fan speed:", round(fan_speed, 4))

	# Convert the start and end date strings into datetime objects
	start_date_time = datetime.strptime(start_date_time, '%Y-%m-%d %H:%M:%S')
	end_date_time = datetime.strptime(end_date_time, '%Y-%m-%d %H:%M:%S')

	# Format the start and end date as strings for further use
	start_date = datetime.strftime(start_date_time, '%Y-%m-%d')
	end_date = datetime.strftime(end_date_time, '%Y-%m-%d')

	# Print the start and end date for reference
	print("start date", start_date)
	print("end date", end_date)

	# Retrieve the local weather data for the specified date range
	data_2020 = get_local_data(start_date, end_date)

	# Reset the index of the data (if necessary) and save it as a CSV file
	data_2020.reset_index(drop=True, inplace=True)
	data_2020.to_csv("data_2020.csv")

	# Read the data back from a CSV file
	data_2020 = pd.read_csv("combined.csv")
	print("wind_speed_factor",wind_speed_factor)
	data_2020['Wind Speed'] = data_2020['Wind Speed'] * wind_speed_factor

	# Convert the 'datetime' column to datetime objects
	data_2020['datetime'] = pd.to_datetime(data_2020['datetime'])

	# Define a function to calculate the heat flux based on internal temperature
	def constant_q_flux(T_internal):
		if T_internal >= (fan_threshold + 273.15):
			return heat_generation + fan_heat_generation  # Include fan heat generation if above threshold
		else:
			return heat_generation  # Otherwise, return only the internal heat generation

	# Get the timezone for the location based on latitude and longitude
	timezone = get_timezone(latitude, longitude)

	# Define a dummy function that always returns 0 for fan speed
	def fan_speed_zero(*args): return 0

	# Define a function to return fan speed based on internal temperature
	def fan_speed_func(T_internal):
		if T_internal >= fan_threshold + 273.15:
			return fan_speed  # Fan operates above the threshold temperature
		else:
			return 0  # Fan remains off if below threshold

	# Print message regarding temperature calculation
	print("mean temp not weighted")

	# Define a function to calculate the average temperature (not weighted)
	def weighted_avg_T(Temperatures, areas, n):
		return np.mean(Temperatures[:, n, -1])  # Return mean temperature at the last time step

	# Print the fan speed for reference
	print(fan_speed)

	# Calculate the total simulation time in seconds
	t_final = (end_date_time - start_date_time).total_seconds()

	# Call the main simulation function with the given parameters
	time_steps, _, avg_temp, battery_temp, dt, outside_temp = \
		run_model_reduced_complexity(
			latitude, longitude, logging, 30, 8, start_date_time, data_2020,
			fan_speed_func, air_velocity_func, weighted_avg_T, internal_convective_heat_transfer_func,
			angle_func, constant_q_flux, h_external, t_final, T_max, T_infinity_func,
			T_initial, k, rho, Cp, G_func, emissivity, absorptivity, B_air, v_air, 
			k_air, alpha_air, battery_Cp, battery_mass, battery_lengths, battery_emissivity,
			thicknesses=thicknesses, L=L, W=W, H=H, N=N, h_max=h_max, 
			include_internal_effects=internal_rad, box_shading=shading, shading_ranges=shading_ranges,
			fan_mixing_ratio = fan_mixing_ratio
		)

	# Create a directory to save the simulation results
	import os
	dir = "../../model_results_numpy/"
	folder_name = "FoCO" + datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
	os.makedirs(os.path.join(dir, folder_name), exist_ok=True)

	# Save simulation results as compressed NumPy files
	np.savez_compressed(os.path.join(dir, folder_name, "time_steps.npz"), data=time_steps.astype(np.float32))
	np.savez_compressed(os.path.join(dir, folder_name, "avg_temp.npz"), data=avg_temp.astype(np.float32))
	np.savez_compressed(os.path.join(dir, folder_name, "battery_temp.npz"), data=battery_temp.astype(np.float32))
	np.savez_compressed(os.path.join(dir, folder_name, "dt.npz"), data=dt)
	np.savez_compressed(os.path.join(dir, folder_name, "outside_temp.npz"), data=outside_temp.astype(np.float32))

	# Create time steps for plotting purposes, converting from seconds to hours
	ts = np.linspace(0, t_final, time_steps.shape[0]) / 3600

	# Return the path to the folder where results are stored
	return os.path.join(dir, folder_name)


