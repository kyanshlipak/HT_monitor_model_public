"""
run_anywhere.py

Used primarily by app.py for user interface plotly-dash app.
Runs either combined solar and heat transfer model (run_combined_anywhere)
or just the heat transfer model (run_anywhere).

Inputs to each function are all relevant variables to similuation
More details in the header comment of each of the two functions

Author: Kyan Shlipak
Date: 09/28
"""



# Define paremeters
import numpy as np
import matplotlib.pyplot as plt
from numerical_modelling import *
from datetime import datetime
import pandas as pd

def run_combined_anywhere(latitude=40.5853, longitude=-105.0844, logging = None,
                             T_max=45 + 273.15, T_initial=20 + 273.15, 
                             k=0.18, rho=1070, Cp=2000, emissivity=0.66, absorptivity=0.66, 
                             battery_mass=1.25, battery_Cp=1000, battery_emissivity=0.62, 
                             battery_lengths=[0.151, 0.065, 0.096], 
                             B_air=0.00367, v_air=15.89e-6, k_air=0.024, alpha_air=22.5e-6, 
                             h_max=200, L=0.2032, W=0.152, H=0.10922, N=4, 
                             thicknesses=[0.004, 0.004, 0.004, 0.004, 0.004, 0.004], 
                             fan_flow=0, heat_generation=0, fan_heat_generation = 0, fan_threshold = 40, 
                             start_date_time='2023-01-01 00:00:00', 
                             end_date_time='2023-12-31 23:00:00',
                             solar_panel_area = 0.2, 
                            solar_panel_tilt = 20,
                            solar_panel_azimuth = 270,
                            solar_panel_efficiency = 0.18,
                            battery_rated_capacity = 120,
                            battery_efficiency = 0.8,
                            dt_solar = 10,
                            power_consumption = 5,
                             bounded = False,
                             quantiles =[0.1, 0.9],
                             stop_event = None,
                             box_shading = False,
                             shading_ranges = []):
  """
  Simulate temperature predictions and solar energy generation for a system located anywhere on Earth.

  Parameters:
  - latitude (float): Geographic latitude of the location (default: 40.5853) - fort collins
  - longitude (float): Geographic longitude of the location (default: -105.0844) - fort collins
  - logging (Logger): Logger for tracking the simulation process.
  - T_max (float): Maximum expected temperature for generating stability criterion.
  - T_initial (float): Initial temperature of the system (K).
  - k (float): Thermal conductivity of the material (W/m*K).
  - rho (float): Material density (kg/m^3).
  - Cp (float): Specific heat capacity of the material (J/kg·K).
  - emissivity (float): Emissivity of the material surface.
  - absorptivity (float): Absorptivity of the material surface, usually equal to emissivity.
  - battery_mass (float): Mass of the battery (kg). - currently unused
  - battery_Cp (float): Specific heat capacity of the battery (J/kg·K). - currently unused
  - battery_emissivity (float): Emissivity of the battery. - currently unused
  - battery_lengths (list): List containing the dimensions (lengths) of the battery. - currently unused
  - B_air (float): Thermal expansion coefficient of air.
  - v_air (float): Kinematic viscosity of air (m^2/s).
  - k_air (float): Thermal conductivity of air (W/m·K).
  - alpha_air (float): Thermal diffusivity of air (m^2/s).
  - h_max (float): Maximum convective heat transfer coefficient (W/m²K) expected (for stability criterion).
  - L (float): Length of the system box (m).
  - W (float): Width of the system box (m).
  - H (float): Height of the system box (m).
  - N (int): Number of discrete points for temperature calculation.
  - thicknesses (list): List of thicknesses of the plates of the enclosure (m).
  - fan_flow (float): Airflow provided by the fan (m³/min).
  - heat_generation (float): Internal heat generation in the enclosure (W).
  - fan_heat_generation (float): Heat generated by the fan (W).
  - fan_threshold (float): Temperature threshold (°C) to activate the fan.
  - start_date_time (str): Starting date and time for the simulation (format: 'YYYY-MM-DD HH:MM:SS').
  - end_date_time (str): Ending date and time for the simulation (format: 'YYYY-MM-DD HH:MM:SS').
  - solar_panel_area (float): Area of the solar panel (m²).
  - solar_panel_tilt (float): Tilt angle of the solar panel (degrees).
  - solar_panel_azimuth (float): Azimuth angle of the solar panel (degrees) relative to north, clockwise.
  - solar_panel_efficiency (float): Efficiency of the solar panel.
  - battery_rated_capacity (float): Rated capacity of the battery (Ah).
  - battery_efficiency (float): Efficiency of the battery.
  - dt_solar (int): Time step for solar panel calculations (seconds).
  - power_consumption (float): Constant power consumption of the system (W).
  - bounded (bool): Whether to bound the system's data using quantiles (default: False).
  - quantiles (list): Quantiles for bounding the data (default: [0.1, 0.9]).
  - stop_event (Event): Event to signal stopping the simulation (default: None).
  - box_shading (bool): Whether to model the system with shading effects (default: False).
  - shading_ranges (list): Time ranges for shading effects, each range is dictionary {t1, t2}.

  Returns:
  - If bounded is True:
    - model_df_lower (DataFrame): Simulation data for lower bound.
    - model_df_upper (DataFrame): Simulation data for upper bound.
    - model_df_2023 (DataFrame): Simulation data for the year 2023.
    - solar_df (DataFrame): Solar energy simulation data.
  - If bounded is False:
    - model_df (DataFrame): Unbounded thermal simulation data.
    - solar_df (DataFrame): Solar energy simulation data.
  """

  if box_shading:
    logging.info("Modeling with box shaded")
  else:
    logging.info("Modeling without box shaded")

  ### Calculated Params
  fan_flow_m3s = fan_flow * 0.0004719471999802417
  fan_speed = fan_flow_m3s / np.mean([L*W, L*H, W*H]) # calculate fan speed to be average of cross sectional velocities

  # make datetime objects from the strings
  start_date_time = datetime.strptime(start_date_time, '%Y-%m-%d %H:%M:%S')
  end_date_time = datetime.strptime(end_date_time, '%Y-%m-%d %H:%M:%S')
  timezone = get_timezone(latitude, longitude)

  # total seconds to simulate
  t_final = (end_date_time - start_date_time).total_seconds()

  # Internal heat generation (with fan heat generation)
  def constant_q_flux(T_internal): 
    if T_internal >= (fan_threshold + 273.15):
      return heat_generation + fan_heat_generation # from fan assembly
    else:
      return heat_generation
  
  # fan speed control (return zero if temp doesn't pass threshold to emulate thermal switch)
  def fan_speed_func(T_internal):
    if T_internal >= (fan_threshold + 273.15):
      return fan_speed
    else:
      return 0
    

  def run_and_output(df, solar = False, solar_df = False):
    time_steps, _, avg_temp, battery_temp, dt, outside_temp = \
      run_model_reduced_complexity_and_memory(latitude, longitude, logging, 30, 7.5, start_date_time, df, 
                                  fan_speed_func, air_velocity_func, avg_T, angle_func, constant_q_flux, h_external, 
                                  t_final, T_max, T_infinity_func, T_initial, 
                                  k, rho, Cp, G_func, emissivity, absorptivity, B_air, v_air, k_air, alpha_air, 
                                  thicknesses = thicknesses, L = L, W =W, H=H,N= N,h_max = h_max, stop_event = stop_event, box_shading = box_shading, shading_ranges = shading_ranges)

    def power_out_func(*args, **kwargs):
      return power_consumption



    model_df = pd.DataFrame({'seconds_past': time_steps})

    # Convert seconds_past to Timedelta and add to base_time
    model_df['datetime'] = model_df['seconds_past'].apply(lambda x: start_date_time + timedelta(seconds=x))
    #model_df['datetime'] = model_df['datetime'].apply(lambda x: convert_to_local(x, timezone))
    model_df['internal'] = avg_temp
    model_df['battery_temp'] = battery_temp
    model_df['outside_temp'] = outside_temp
    model_df.set_index('datetime', inplace=True)

    if solar:
      print(f"*** Modelling Solar ({latitude}, {longitude}) ***")
      logging.info(solar_df.head(5))
      start_solar_time = datetime.strptime("2014-01-01 00:00:00", '%Y-%m-%d %H:%M:%S')
      end_solar_time = datetime.strptime("2023-12-31 23:59:59", '%Y-%m-%d %H:%M:%S')
      
      solar_time_steps, charges, power_ins, power_outs = solar_panel_model(latitude = latitude, longitude = longitude, logging = logging, start_date_time = start_solar_time, end_date_time = end_solar_time, df =solar_df,
                          solar_panel_area = solar_panel_area, solar_panel_tilt = solar_panel_tilt, solar_panel_azimuth = solar_panel_azimuth, solar_panel_efficiency = solar_panel_efficiency, 
                          battery_rated_capacity = battery_rated_capacity, battery_efficiency = battery_efficiency, dt = dt_solar,
                          power_out_func = power_out_func, stop_event = stop_event, shading_ranges = shading_ranges)

      solar_df = pd.DataFrame({'seconds_past': solar_time_steps})
      solar_df['datetime'] = solar_df['seconds_past'].apply(lambda x: start_solar_time + timedelta(seconds=x))
      #solar_df['datetime'] = solar_df['datetime'].apply(lambda x: convert_to_local(x, timezone))
      solar_df['charges'] = charges
      solar_df['power_ins'] = power_ins
      solar_df['power_outs'] = power_outs
      solar_df.set_index('datetime', inplace=True)
      return model_df, solar_df
    else:
      return model_df

  if bounded:
    logging.info("*** Running Bounded ***")

    # get 21 years of data, mean, and bounds
    data_2020_lower, data_2020_upper, df_mean, df_all = get_data_bound(latitude=latitude, 
                                                      longitude=longitude, 
                                                      start_date_time = start_date_time,
                                                      end_date_time = end_date_time,
                                                      timezone = timezone,
                                                      quantiles = quantiles,
                                                      logging = logging,
                                                      stop_event = stop_event,
                                                      all = True
    )
    df_all = df_all.loc[(df_all['datetime'] >= "2014-01-01 00:00:00") & (df_all['datetime'] <= "2023-12-31 23:59:59")]
    df_all['seconds'] = (df_all['datetime'] - df_all['datetime'].iloc[0]).dt.total_seconds()

    # get 2023 data
    df_2023 = get_data(latitude=latitude, 
                        longitude=longitude, 
                        start_date_time = start_date_time,
                        end_date_time = end_date_time,
                        timezone = timezone,
                        logging = logging,
                        stop_event = stop_event
    )

    try:     
      # run model for lower bound, upper bound, and 2023
      model_df_lower = run_and_output(data_2020_lower)
      model_df_upper = run_and_output(data_2020_upper)
      model_df_2023, solar_df  = run_and_output(df_2023, solar = True, solar_df = df_all)

      return model_df_lower, model_df_upper, model_df_2023, solar_df 
    except Exception as e:
      logging.error("Error running model: " + str(e))
      return "", "", "", ""

  else:
    logging.info("*** Running unbounded ***")
    # get unbounded data: 2023 and 2001 - 2023
    df_2023 = get_data(latitude=latitude, 
                                                      longitude=longitude, 
                                                      start_date_time = start_date_time,
                                                      end_date_time = end_date_time,
                                                      timezone = timezone,
                                                      logging = logging,
                                                      stop_event = stop_event
    )

    df_all = get_data(latitude=latitude, 
                                                      longitude=longitude, 
                                                      start_date_time = datetime.strptime("2014-01-01 00:00:00", '%Y-%m-%d %H:%M:%S'),
                                                      end_date_time = datetime.strptime("2023-12-31 23:59:59", '%Y-%m-%d %H:%M:%S'),
                                                      timezone = timezone,
                                                      logging = logging,
                                                      stop_event = stop_event)

    try: 
      # run predictive heat transfer and solar models
      model_df, solar_df = run_and_output(df_2023, solar = True, solar_df = df_all)
      return model_df, solar_df
    except Exception as e:
      logging.error("Error running model" + str(e))
      return "", ""

def run_anywhere(latitude=40.5853, longitude=-105.0844, logging = None,
                             T_max=45 + 273.15, T_initial=20 + 273.15, 
                             k=0.18, rho=1070, Cp=2000, emissivity=0.66, absorptivity=0.66, 
                             battery_mass=1.25, battery_Cp=1000, battery_emissivity=0.62, 
                             battery_lengths=[0.151, 0.065, 0.096], 
                             B_air=0.00367, v_air=15.89e-6, k_air=0.024, alpha_air=22.5e-6, 
                             h_max=200, L=0.2032, W=0.152, H=0.10922, N=4, 
                             thicknesses=[0.004, 0.004, 0.004, 0.004, 0.004, 0.004], 
                             fan_flow=0, heat_generation=0, fan_heat_generation = 0, fan_threshold = 40, 
                             start_date_time='2023-01-01 00:00:00', 
                             end_date_time='2023-12-31 23:00:00',
                             bounded = False,
                             quantiles =[0.05, 0.95],
                             stop_event = None,
                             box_shading = False,
                             shading_ranges = []):

  """
  Simulate thermal and solar energy performance for a system located at any specified location on Earth.

  This function predicts system temperature and solar energy generation based on geographic coordinates and system parameters. It supports a wide range of inputs related to material properties, enclosure dimensions, thermal effects, and fan operation. The simulation runs between a user-specified start and end date, and optionally includes bounding via quantiles and shading effects.

  Parameters:
  - latitude (float): Latitude of the location in degrees (default: 40.5853 for Fort Collins).
  - longitude (float): Longitude of the location in degrees (default: -105.0844 for Fort Collins).
  - logging (Logger): Logger instance to track the simulation process.
  - T_max (float): Maximum expected system temperature in Kelvin.
  - T_initial (float): Initial system temperature in Kelvin.
  - k (float): Thermal conductivity of the system material (W/m*K).
  - rho (float): Material density (kg/m^3).
  - Cp (float): Specific heat capacity of the material (J/kg*K).
  - emissivity (float): Emissivity of the system surface.
  - absorptivity (float): Absorptivity of the system surface.
  - battery_mass (float): Mass of the battery in kg (currently unused).
  - battery_Cp (float): Specific heat capacity of the battery (currently unused).
  - battery_emissivity (float): Emissivity of the battery surface (currently unused).
  - battery_lengths (list): Dimensions of the battery in meters (currently unused).
  - B_air (float): Thermal expansion coefficient of air.
  - v_air (float): Kinematic viscosity of air (m^2/s).
  - k_air (float): Thermal conductivity of air (W/m*K).
  - alpha_air (float): Thermal diffusivity of air (m^2/s).
  - h_max (float): Maximum expected convective heat transfer coefficient (W/m²*K).
  - L (float): Length of the system enclosure (m).
  - W (float): Width of the system enclosure (m).
  - H (float): Height of the system enclosure (m).
  - N (int): Number of discrete points for temperature calculation.
  - thicknesses (list): List of thicknesses of enclosure plates (m).
  - fan_flow (float): Airflow provided by the fan (m³/min).
  - heat_generation (float): Internal heat generation within the enclosure (W).
  - fan_heat_generation (float): Heat generated by the fan (W).
  - fan_threshold (float): Temperature threshold (°C) to activate the fan.
  - start_date_time (str): Start date and time for the simulation (format: 'YYYY-MM-DD HH:MM:SS').
  - end_date_time (str): End date and time for the simulation (format: 'YYYY-MM-DD HH:MM:SS').
  - bounded (bool): Whether to bound the simulation data using quantiles (default: False).
  - quantiles (list): Quantiles to bound the data (default: [0.05, 0.95]).
  - stop_event (Event): Event to signal stopping the simulation (optional).
  - box_shading (bool): Whether to include shading effects in the simulation (default: False).
  - shading_ranges (list): List of shading periods as dictionaries, each containing start and end times.

  Returns:
  - If `bounded` is True:
    - model_df_lower (DataFrame): Lower bound of the thermal simulation data.
    - model_df_upper (DataFrame): Upper bound of the thermal simulation data.
    - model_df_2023 (DataFrame): Thermal simulation data for the year 2023.
    - solar_df (DataFrame): Solar energy generation data.
  - If `bounded` is False:
    - model_df (DataFrame): Unbounded thermal simulation data.
    - solar_df (DataFrame): Solar energy generation data.
  """
    
  if box_shading:
      logging.info("Modelling with box shaded")
  else:
    logging.info("Modelling without box shaded")

  ### Calculated Params
  fan_flow_m3s = fan_flow * 0.0004719471999802417
  fan_speed = fan_flow_m3s / np.mean([L*W, L*H, W*H])

  start_date_time = datetime.strptime(start_date_time, '%Y-%m-%d %H:%M:%S')
  end_date_time = datetime.strptime(end_date_time, '%Y-%m-%d %H:%M:%S')
  timezone = get_timezone(latitude, longitude)
  t_final = (end_date_time - start_date_time).total_seconds()

  def constant_q_flux(T_internal): 
    if T_internal >= (fan_threshold + 273.15):
      return heat_generation + fan_heat_generation # from fan assembly
    else:
      return heat_generation

  def fan_speed_func(T_internal):
    if T_internal > (fan_threshold + 273.15):
      return fan_speed
    else:
      return 0
    

  def run_and_output(data_2020):
    time_steps, _, avg_temp, battery_temp, dt, outside_temp = \
      run_model_reduced_complexity_and_memory(latitude, longitude, logging, 30, 7.5, start_date_time, data_2020, 
                                  fan_speed_func, air_velocity_func, avg_T, angle_func, constant_q_flux, h_external, 
                                  t_final, T_max, T_infinity_func, T_initial, 
                                  k, rho, Cp, G_func, emissivity, absorptivity, B_air, v_air, k_air, alpha_air, 
                                  thicknesses = thicknesses, L = L, W =W, H=H,N= N,h_max = h_max, stop_event = stop_event, 
                                  box_shading = box_shading, shading_ranges = shading_ranges)



    import os
    dir = "../../model_results_numpy/"
    folder_name = f"{int(latitude)}_{int(longitude)}_" + datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    os.makedirs(os.path.join(dir, folder_name), exist_ok=True)
    np.savez_compressed(os.path.join(dir, folder_name, "time_steps.npz"), data = time_steps.astype(np.float32))
    np.savez_compressed(os.path.join(dir, folder_name, "avg_temp.npz"),  data = avg_temp.astype(np.float32))
    np.savez_compressed(os.path.join(dir, folder_name, "battery_temp.npz"),  data = battery_temp.astype(np.float32))
    np.savez_compressed(os.path.join(dir, folder_name, "dt.npz"),  data = dt)
    np.savez_compressed(os.path.join(dir, folder_name, "outside_temp.npz"),  data = outside_temp.astype(np.float32))
    return os.path.join(dir, folder_name)

  if bounded:
    logging.info("*** Running Bounded ***")
    data_2020_lower, data_2020_upper, _ = get_data_bound(latitude=latitude, 
                                                      longitude=longitude, 
                                                      start_date_time = start_date_time,
                                                      end_date_time = end_date_time,
                                                      timezone = timezone,
                                                      quantiles = quantiles,
                                                      logging = logging,
                                                      stop_event = stop_event
    )

    df_mean = get_data(latitude=latitude, 
                                                      longitude=longitude, 
                                                      start_date_time = start_date_time,
                                                      end_date_time = end_date_time,
                                                      timezone = timezone,
                                                      logging = logging,
                                                      stop_event = stop_event
    )

    try:     
      results_dir_lower = run_and_output(data_2020_lower)
      results_dir_upper = run_and_output(data_2020_upper)
      results_dir_mean = run_and_output(df_mean)
      return results_dir_lower, results_dir_upper, results_dir_mean
    except Exception as e:
      logging.error("Error running model: " + str(e))
      return "", "", ""

  else:
    logging.info("*** Running unbounded ***")
    df_mean = get_data(latitude=latitude, 
                                                      longitude=longitude, 
                                                      start_date_time = start_date_time,
                                                      end_date_time = end_date_time,
                                                      timezone = timezone,
                                                      logging = logging,
                                                      stop_event = stop_event
    )

    
    try: 
      results_dir = run_and_output(df_mean)
      return results_dir
    except Exception as e:
      logging.error("Error running model" + str(e))
      return ""